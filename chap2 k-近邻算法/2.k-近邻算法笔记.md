
# 机器学习实战 
**学习一样事物最好的方式就是带有目标的，从应用的角度去学习。相较于针对于方法，学习更有动力因为能看到效果。**
**[wwm-yingz](wangweiming.me)**

# 第一部分 分类
# chap2  k-近邻算法

k-近邻算法**采用测量不同特征值之间的距离方法进行分类**。  


优点：精度高，对异常值不敏感，无数据输入假定  
缺点：计算复杂度高，空间复杂度高  
适用范围：数值型和标称型  

## 一般流程
1. 收集数据
2. 准备数据
3. 分析数据
4. 训练算法(k-邻近算法是不需要训练的)
5. 测试算法
6. 使用算法



## 伪代码  
1. 计算已知类别数据集中的点和当前点之间的距离
2. 按照距离递增次序排序
3. 选取与当前点距离最小的k个点
4. 确定前k个点所在类别的出现频率
5. 返回前k个点出现频率最高的类别作为当前点的预测分析

对应kNN.py中 *classify0()*  
部分函数说明：
> **tile(array,(d1,d2...dn))**
>
>
>  (d1,d2...dn)代表了n维，其中每个单元都是array  
>  例子：  
>   a = np.array([0,1,2])  
>   b = np.tile(a,2)  
>   b = (  [0,1,2,0,1,2]  )   一维数组
>   c = np.tile(a,(1,2))  
>   c = ([ [0,1,2,0,1,2] ])   二维数组!!注意与上一行的区别  

> **array.argsort()**
>
> 返回值是数组值从小到大的索引  
>   x = np.array([3, 1, 2])  
>   np.argsort(x)  
>   =>array([1, 2, 0])  
>   x = np.array([[0, 3],
>                 [2, 2]])  
    np.argsort(x, axis=0) #按列排序  
    =>array([[0, 1],
           [1, 0]])
    几维矩阵返回几维矩阵作为结果    


## k-近邻算法总结:
通过k-近邻算法可以构造分类器。该分类器不需要进行训练，但是分类过程中必须使用大量接近实际数据的训练样本。因为必须要计算待分类样本与每个训练样本的距离。时间和空间复杂度都较高。另一个缺点是无法给出数据的结构信息，故不能知道典型实例样本具有什么特征。  
测试中存在的问题：  
虽然整体识别正确率很高10/946，但是仍有显然很显然的数字被识别错误。例如下图的8被识别为1 。应该是因为该数字太细，与不少数字1的宽度相近，故会被识别错误，进一步的改进方式可以考虑成比例的将所有数字拉长拉宽成等大，进一步提高正确率。  
00000000000011111111000000000000  
00000000000111111111100000000000  
00000000001111111111110000000000  
00000000001111111111111000000000  
00000000011111111111111000000000  
00000000111111111111111000000000  
00000000011111000001111100000000  
00000000011111000011111000000000  
00000000111110000111110000000000  
00000000011111100111111000000000  
00000000011111001111110000000000  
00000000011111111111100000000000  
00000000001111111111100000000000  
00000000001111111111000000000000  
00000000001111111110000000000000  
00000000000111111110000000000000  
00000000000111111000000000000000  
00000000001111111000000000000000  
00000000001111111100000000000000  
00000000011111111100000000000000  
00000000111111111100000000000000  
00000000111111111111000000000000  
00000000111111011111000000000000  
00000000111110011111000000000000  
00000000111110000111110000000000  
00000000111100000111110000000000  
00000000111100000111110000000000  
00000000011111000111111000000000  
00000000001111101111110000000000  
00000000001111111111110000000000  
00000000000111111111110000000000  
00000000000011111111100000000000   



